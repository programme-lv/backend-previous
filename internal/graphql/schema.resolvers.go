package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"net/mail"

	"github.com/99designs/gqlgen/graphql"
	"github.com/programme-lv/backend/internal/execution"
	"github.com/programme-lv/backend/internal/models"
	"golang.org/x/crypto/bcrypt"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (*User, error) {
	log.Println("Logging in user", username)

	// Get the user from the database
	var user models.User
	err := r.DB.Get(&user, "SELECT * FROM users WHERE username = $1", username)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("username or password is incorrect")
	} else if err != nil {
		return nil, err
	}

	// Verify the password
	err = bcrypt.CompareHashAndPassword([]byte(user.HashedPassword), []byte(password))
	if err != nil {
		return nil, fmt.Errorf("username or password is incorrect")
	}

	// Set the user ID in the session
	r.SessionManager.Put(ctx, "user_id", user.ID)

	return &User{
		ID:       fmt.Sprintf("%d", user.ID),
		Username: user.Username,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, password string, email string, firstName string, lastName string) (*User, error) {
	log.Println("Registering user", username)

	// validate registration data
	if username == "" || password == "" {
		return nil, fmt.Errorf("username and password are required")
	}
	if len(password) < 8 {
		return nil, fmt.Errorf("password must be at least 8 characters")
	}
	if len(password) > 32 {
		return nil, fmt.Errorf("password must be at most 32 characters")
	}
	if len(username) < 3 {
		return nil, fmt.Errorf("username must be at least 3 characters")
	}
	if len(username) > 15 {
		return nil, fmt.Errorf("username must be at most 15 characters")
	}

	// check if user with the same username already exists
	var userWithUsernameCount int
	err := r.DB.QueryRow("SELECT COUNT(*) FROM users WHERE username = $1", username).Scan(&userWithUsernameCount)
	if err != nil {
		return nil, err
	}

	if userWithUsernameCount > 0 {
		return nil, fmt.Errorf("user with that username already exists")
	}

	// check if user with the same email already exists
	var userWithEmailCount int
	err = r.DB.QueryRow("SELECT COUNT(*) FROM users WHERE email = $1", email).Scan(&userWithEmailCount)
	if err != nil {
		return nil, err
	}

	if userWithEmailCount > 0 {
		return nil, fmt.Errorf("user with that email already exists")
	}

	// validate email
	_, err = mail.ParseAddress(email)
	if err != nil {
		return nil, err
	}

	// hash password
	var hashedPassword []byte
	hashedPassword, err = bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}
	password = string(hashedPassword)

	// create user
	_, err = r.DB.Exec("INSERT INTO users (username, hashed_password, email, first_name, last_name, created_at) VALUES ($1, $2, $3, $4, $5, now())", username, password, email, firstName, lastName)
	if err != nil {
		return nil, err
	}

	// scan user id
	var userID int
	err = r.DB.QueryRow("SELECT id FROM users WHERE username = $1", username).Scan(&userID)
	if err != nil {
		return nil, err
	}

	return &User{
		ID:       fmt.Sprintf("%d", userID),
		Username: username,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Delete the user ID from the sessiong
	userId, ok := r.SessionManager.Pop(ctx, "user_id").(int64)

	if ok {
		log.Println("User", userId, "logged out")
		return true, nil
	} else {
		log.Println("User attempted to log out without being logged in")
		return false, fmt.Errorf("not logged in")
	}
}

// EnqueueSubmission is the resolver for the enqueueSubmission field.
func (r *mutationResolver) EnqueueSubmission(ctx context.Context, taskID string, languageID string, code string) (*Submission, error) {
	panic(fmt.Errorf("not implemented: EnqueueSubmission - enqueueSubmission"))
}

// ExecuteCode is the resolver for the executeCode field.
func (r *mutationResolver) ExecuteCode(ctx context.Context, code string, languageID string) (*ExecutionResult, error) {
	log.Println("Executing code in language", languageID, ":", code)
	factory := execution.ExecuterFactory{DB: r.DB}
	executable, err := factory.NewExecuter(languageID, code)
	if err != nil {
		return nil, err
	}
	defer executable.Cleanup()

	// execute code
	result, err := executable.Execute()
	if err != nil {
		return nil, err
	}

	return &ExecutionResult{
		Stdout: result.Stdout,
		Stderr: result.Stderr,
	}, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, id string, fullName string) (*Task, error) {
	panic(fmt.Errorf("not implemented: CreateTask - createTask"))
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, id string, fullName string, origin *string, authors []string) (*Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTask - updateTask"))
}

// CreateTaskVersion is the resolver for the createTaskVersion field.
func (r *mutationResolver) CreateTaskVersion(ctx context.Context) (*TaskVersion, error) {
	panic(fmt.Errorf("not implemented: CreateTaskVersion - createTaskVersion"))
}

// UpdateTaskVersion is the resolver for the updateTaskVersion field.
func (r *mutationResolver) UpdateTaskVersion(ctx context.Context, id string, versionName *string, timeLimitMs *int, memoryLimitMb *int, evalTypeID *string) (*TaskVersion, error) {
	panic(fmt.Errorf("not implemented: UpdateTaskVersion - updateTaskVersion"))
}

// Whoami is the resolver for the whoami field.
func (r *queryResolver) Whoami(ctx context.Context) (*User, error) {
	// Get the user ID from the session
	userID, ok := r.SessionManager.Get(ctx, "user_id").(int64)
	if !ok {
		return nil, fmt.Errorf("not logged in")
	}

	// Get the user from the database
	var user models.User
	err := r.DB.Get(&user, "SELECT * FROM users WHERE id = $1", userID)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("user not found")
	}

	return &User{
		ID:       fmt.Sprintf("%d", user.ID),
		Username: user.Username,
	}, nil
}

// ListSubmissions is the resolver for the listSubmissions field.
func (r *queryResolver) ListSubmissions(ctx context.Context) ([]*Submission, error) {
	panic(fmt.Errorf("not implemented: ListSubmissions - listSubmissions"))
}

// ListLanguages is the resolver for the listLanguages field.
func (r *queryResolver) ListLanguages(ctx context.Context) ([]*Language, error) {
	log.Println("Received request for languages")

	var langs []models.ProgrammingLanguage
	err := r.DB.Select(&langs, "SELECT * FROM programming_languages")
	if err != nil {
		return nil, err
	}

	// convert to graphql type
	var gqlLangs []*Language
	for _, lang := range langs {
		gqlLangs = append(gqlLangs, &Language{
			ID:       lang.ID,
			FullName: lang.FullName,
			MonacoID: lang.MonacoId,
		})
	}

	return gqlLangs, nil
}

// ListTasks is the resolver for the listTasks field.
func (r *queryResolver) ListTasks(ctx context.Context) ([]*Task, error) {
	log.Println("Received request to list tasks")

	var tasks []models.Task
	err := r.DB.Select(&tasks, "SELECT * FROM tasks")
	if err != nil {
		return nil, err
	}

	// convert to graphql type
	var gqlTasks []*Task
	for _, task := range tasks {
		gqlTasks = append(gqlTasks, &Task{
			ID:       task.ID,
			FullName: task.FullName,
			Origin:   task.Origin,
		})
	}

	fields := graphql.CollectFieldsCtx(ctx, nil)
	for _, field := range fields {
		switch field.Name {
		case "versions":
			// prefetch versions
			var versions []models.TaskVersion
			err := r.DB.Select(&versions, "SELECT * FROM task_versions")
			if err != nil {
				return nil, err
			}

			// group versions by task id
			taskIdVersions := make(map[string][]models.TaskVersion)
			for _, version := range versions {
				taskIdVersions[version.TaskID] = append(taskIdVersions[version.TaskID], version)
			}

			// prefetch eval types
			evalTypeIDs := make(map[string]models.EvalType)
			var evalTypes []models.EvalType
			err = r.DB.Select(&evalTypes, "SELECT * FROM eval_types")
			if err != nil {
				return nil, err
			}
			for _, evalType := range evalTypes {
				evalTypeIDs[evalType.ID] = evalType
			}

			// add versions to tasks
			for _, gqlTask := range gqlTasks {
				for _, version := range taskIdVersions[gqlTask.ID] {
					var updatedAt *string = nil
					if version.UpdatedAt != nil {
						updatedAtValue := version.UpdatedAt.String()
						updatedAt = &updatedAtValue
					}

					gqlTask.Versions = append(gqlTask.Versions, &TaskVersion{
						ID:            fmt.Sprintf("%d", version.ID),
						VersionName:   version.VersionName,
						TimeLimitMs:   version.TimeLimMs,
						MemoryLimitMb: version.MemLimKb,
						EvalType: &EvalType{
							ID:            version.EvalTypeID,
							DescriptionEn: evalTypeIDs[version.EvalTypeID].DescriptionEn,
						},
						CreatedAt: version.CreatedAt.String(),
						UpdatedAt: updatedAt,
					})
				}
			}
		case "authors":
			// prefetch authors
			var authors []models.TaskAuthor
			err := r.DB.Select(&authors, "SELECT * FROM task_authors")
			if err != nil {
				return nil, err
			}

			// group authors by task id
			taskIdAuthors := make(map[string][]models.TaskAuthor)
			for _, author := range authors {
				taskIdAuthors[author.TaskID] = append(taskIdAuthors[author.TaskID], author)
			}

			// add authors to tasks
			for _, gqlTask := range gqlTasks {
				for _, author := range taskIdAuthors[gqlTask.ID] {
					gqlTask.Authors = append(gqlTask.Authors, author.Author)
				}
			}
		}
	}

	return gqlTasks, nil
}

// GetTask is the resolver for the getTask field.
func (r *queryResolver) GetTask(ctx context.Context, id string) (*Task, error) {
	log.Println("Received request to get task", id)

	var task models.Task
	err := r.DB.Get(&task, "SELECT * FROM tasks WHERE id = $1", id)
	if err != nil {
		return nil, err
	}

	gqlTask := &Task{
		ID:       task.ID,
		FullName: task.FullName,
		Origin:   task.Origin,
	}

	fields := graphql.CollectFieldsCtx(ctx, nil)
	for _, field := range fields {
		switch field.Name {
		case "versions":
			log.Println("task versions requested")

			// prefetch versions
			var versions []models.TaskVersion
			err := r.DB.Select(&versions, "SELECT * FROM task_versions WHERE task_id = $1", gqlTask.ID)
			if err != nil {
				return nil, err
			}

			// prefetch eval types
			var evalTypes []models.EvalType
			err = r.DB.Select(&evalTypes, "SELECT * FROM eval_types")
			if err != nil {
				return nil, err
			}

			// group eval types by id
			evalTypeIDs := make(map[string]models.EvalType)
			for _, evalType := range evalTypes {
				evalTypeIDs[evalType.ID] = evalType
			}

			// add versions to tasks
			for _, version := range versions {
				var updatedAt *string = nil
				if version.UpdatedAt != nil {
					updatedAtValue := version.UpdatedAt.String()
					updatedAt = &updatedAtValue
				}

				gqlTask.Versions = append(gqlTask.Versions, &TaskVersion{
					ID:            fmt.Sprintf("%d", version.ID),
					VersionName:   version.VersionName,
					TimeLimitMs:   version.TimeLimMs,
					MemoryLimitMb: version.MemLimKb,
					EvalType: &EvalType{
						ID:            version.EvalTypeID,
						DescriptionEn: evalTypeIDs[version.EvalTypeID].DescriptionEn,
					},
					CreatedAt: version.CreatedAt.String(),
					UpdatedAt: updatedAt,
				})
			}
		case "authors":
			log.Println("task authors requested")

			// prefetch authors
			var authors []models.TaskAuthor
			err := r.DB.Select(&authors, "SELECT * FROM task_authors WHERE task_id = $1", task.ID)
			if err != nil {
				return nil, err
			}

			for _, author := range authors {
				gqlTask.Authors = append(gqlTask.Authors, author.Author)
			}
		}
	}

	return gqlTask, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
