package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"net/mail"

	"github.com/programme-lv/backend/internal/execution"
	"github.com/programme-lv/backend/internal/models"
	"golang.org/x/crypto/bcrypt"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (*User, error) {
	log.Println("Logging in user", username)

	// Get the user from the database
	var user models.User
	err := r.DB.Get(&user, "SELECT * FROM users WHERE username = $1", username)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("username or password is incorrect")
	} else if err != nil {
		return nil, err
	}

	// Verify the password
	err = bcrypt.CompareHashAndPassword([]byte(user.HashedPassword), []byte(password))
	if err != nil {
		return nil, fmt.Errorf("username or password is incorrect")
	}

	// Set the user ID in the session
	r.SessionManager.Put(ctx, "user_id", user.ID)

	return &User{
		ID:       fmt.Sprintf("%d", user.ID),
		Username: user.Username,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, password string, email string, firstName string, lastName string) (*User, error) {
	log.Println("Registering user", username)

	// validate registration data
	if username == "" || password == "" {
		return nil, fmt.Errorf("username and password are required")
	}
	if len(password) < 8 {
		return nil, fmt.Errorf("password must be at least 8 characters")
	}
	if len(password) > 32 {
		return nil, fmt.Errorf("password must be at most 32 characters")
	}
	if len(username) < 3 {
		return nil, fmt.Errorf("username must be at least 3 characters")
	}
	if len(username) > 15 {
		return nil, fmt.Errorf("username must be at most 15 characters")
	}

	// check if user with the same username already exists
	var userWithUsernameCount int
	err := r.DB.QueryRow("SELECT COUNT(*) FROM users WHERE username = $1", username).Scan(&userWithUsernameCount)
	if err != nil {
		return nil, err
	}

	if userWithUsernameCount > 0 {
		return nil, fmt.Errorf("user with that username already exists")
	}

	// check if user with the same email already exists
	var userWithEmailCount int
	err = r.DB.QueryRow("SELECT COUNT(*) FROM users WHERE email = $1", email).Scan(&userWithEmailCount)
	if err != nil {
		return nil, err
	}

	if userWithEmailCount > 0 {
		return nil, fmt.Errorf("user with that email already exists")
	}

	// validate email
	_, err = mail.ParseAddress(email)
	if err != nil {
		return nil, err
	}

	// hash password
	var hashedPassword []byte
	hashedPassword, err = bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}
	password = string(hashedPassword)

	// create user
	_, err = r.DB.Exec("INSERT INTO users (username, hashed_password, email, first_name, last_name, created_at) VALUES ($1, $2, $3, $4, $5, now())", username, password, email, firstName, lastName)
	if err != nil {
		return nil, err
	}

	// scan user id
	var userID int
	err = r.DB.QueryRow("SELECT id FROM users WHERE username = $1", username).Scan(&userID)
	if err != nil {
		return nil, err
	}

	return &User{
		ID:       fmt.Sprintf("%d", userID),
		Username: username,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Delete the user ID from the sessiong
	userId, ok := r.SessionManager.Pop(ctx, "user_id").(int64)

	if ok {
		log.Println("User", userId, "logged out")
		return true, nil
	} else {
		log.Println("User attempted to log out without being logged in")
		return false, fmt.Errorf("not logged in")
	}
}

// EnqueueSubmission is the resolver for the enqueueSubmission field.
func (r *mutationResolver) EnqueueSubmission(ctx context.Context, taskID string, languageID string, code string) (*Submission, error) {
	panic(fmt.Errorf("not implemented: EnqueueSubmission - enqueueSubmission"))
}

// ExecuteCode is the resolver for the executeCode field.
func (r *mutationResolver) ExecuteCode(ctx context.Context, code string, languageID string) (*ExecutionResult, error) {
	log.Println("Executing code in language", languageID, ":", code)
	factory := execution.ExecuterFactory{DB: r.DB}
	executable, err := factory.NewExecuter(languageID, code)
	if err != nil {
		return nil, err
	}
	defer executable.Cleanup()

	// execute code
	result, err := executable.Execute()
	if err != nil {
		return nil, err
	}

	return &ExecutionResult{
		Stdout: result.Stdout,
		Stderr: result.Stderr,
	}, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, id string, fullName string) (*Task, error) {
	panic(fmt.Errorf("not implemented: CreateTask - createTask"))
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, id string, fullName string, origin *string, authors []string) (*Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTask - updateTask"))
}

// CreateTaskVersion is the resolver for the createTaskVersion field.
func (r *mutationResolver) CreateTaskVersion(ctx context.Context) (*TaskVersion, error) {
	panic(fmt.Errorf("not implemented: CreateTaskVersion - createTaskVersion"))
}

// UpdateTaskVersion is the resolver for the updateTaskVersion field.
func (r *mutationResolver) UpdateTaskVersion(ctx context.Context, id string, versionName *string, timeLimitMs *int, memoryLimitMb *int, evalTypeID *string) (*TaskVersion, error) {
	panic(fmt.Errorf("not implemented: UpdateTaskVersion - updateTaskVersion"))
}

// Whoami is the resolver for the whoami field.
func (r *queryResolver) Whoami(ctx context.Context) (*User, error) {
	// Get the user ID from the session
	userID, ok := r.SessionManager.Get(ctx, "user_id").(int64)
	if !ok {
		return nil, fmt.Errorf("not logged in")
	}

	// Get the user from the database
	var user models.User
	err := r.DB.Get(&user, "SELECT * FROM users WHERE id = $1", userID)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("user not found")
	}

	return &User{
		ID:       fmt.Sprintf("%d", user.ID),
		Username: user.Username,
	}, nil
}

// ListSubmissions is the resolver for the listSubmissions field.
func (r *queryResolver) ListSubmissions(ctx context.Context) ([]*Submission, error) {
	panic(fmt.Errorf("not implemented: ListSubmissions - listSubmissions"))
}

// ListLanguages is the resolver for the listLanguages field.
func (r *queryResolver) ListLanguages(ctx context.Context) ([]*Language, error) {
	var langs []models.ProgrammingLanguage
	err := r.DB.Select(&langs, "SELECT * FROM programming_languages")
	if err != nil {
		return nil, err
	}

	// convert to graphql type
	var gqlLangs []*Language
	for _, lang := range langs {
		gqlLangs = append(gqlLangs, &Language{
			ID:       lang.ID,
			FullName: lang.FullName,
			MonacoID: lang.MonacoId,
		})
	}

	return gqlLangs, nil
}

// ListTasks is the resolver for the listTasks field.
func (r *queryResolver) ListTasks(ctx context.Context) ([]*Task, error) {
	panic(fmt.Errorf("not implemented: ListTasks - listTasks"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
