package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"database/sql"
	"fmt"
	"net/mail"

	"github.com/programme-lv/backend/internal/models"
	"golang.org/x/crypto/bcrypt"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (*PublicUser, error) {
	// Get the user from the database
	var user models.User
	err := r.DB.Get(&user, "SELECT * FROM users WHERE username = $1", username)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("username or password is incorrect")
	} else if err != nil {
		return nil, err
	}

	// Verify the password
	err = bcrypt.CompareHashAndPassword([]byte(user.HashedPassword), []byte(password))
	if err != nil {
		return nil, fmt.Errorf("username or password is incorrect")
	}

	// Set the user ID in the session
	r.SessionManager.Put(ctx, "userID", user.ID)

	return &PublicUser{
		ID:       fmt.Sprintf("%d", user.ID),
		Username: user.Username,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, password string, email string, firstName string, lastName string) (*PublicUser, error) {
	// validate registration data
	if username == "" || password == "" {
		return nil, fmt.Errorf("username and password are required")
	}
	if len(password) < 8 {
		return nil, fmt.Errorf("password must be at least 8 characters")
	}
	if len(password) > 32 {
		return nil, fmt.Errorf("password must be at most 32 characters")
	}
	if len(username) < 3 {
		return nil, fmt.Errorf("username must be at least 3 characters")
	}
	if len(username) > 15 {
		return nil, fmt.Errorf("username must be at most 15 characters")
	}

	// check if user with the same username already exists
	var userWithUsernameCount int
	err := r.DB.QueryRow("SELECT COUNT(*) FROM users WHERE username = $1", username).Scan(&userWithUsernameCount)
	if err != nil {
		return nil, err
	}

	if userWithUsernameCount > 0 {
		return nil, fmt.Errorf("user with that username already exists")
	}

	// validate email
	_, err = mail.ParseAddress(email)
	if err != nil {
		return nil, err
	}

	// hash password
	var hashedPassword []byte
	hashedPassword, err = bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}
	password = string(hashedPassword)

	// create user
	_, err = r.DB.Exec("INSERT INTO users (username, hashed_password, email, first_name, last_name, created_at) VALUES ($1, $2, $3, $4, $5, now())", username, password, email, firstName, lastName)
	if err != nil {
		return nil, err
	}

	// scan user id
	var userID int
	err = r.DB.QueryRow("SELECT id FROM users WHERE username = $1", username).Scan(&userID)
	if err != nil {
		return nil, err
	}

	return &PublicUser{
		ID:       fmt.Sprintf("%d", userID),
		Username: username,
	}, nil
}

// Whoami is the resolver for the whoami field.
func (r *queryResolver) Whoami(ctx context.Context) (*PublicUser, error) {
	panic(fmt.Errorf("not implemented: Whoami - whoami"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *queryResolver) Login(ctx context.Context, username string, password string) (*PublicUser, error) {
	return nil, nil
}
