// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"fmt"
	"io"
	"strconv"
)

type Constraints struct {
	TimeLimitMs   int `json:"timeLimitMs"`
	MemoryLimitKb int `json:"memoryLimitKb"`
}

type Description struct {
	Story    string     `json:"story"`
	Input    string     `json:"input"`
	Output   string     `json:"output"`
	Examples []*Example `json:"examples,omitempty"`
	Notes    *string    `json:"notes,omitempty"`
}

type Evaluation struct {
	ID            string `json:"id"`
	Status        string `json:"status"`
	TotalScore    int    `json:"totalScore"`
	PossibleScore *int   `json:"possibleScore,omitempty"`
	// Some programming languages do not support compilation, so this field may be null.
	CompileRData *RuntimeData  `json:"compileRData,omitempty"`
	TestResults  []*TestResult `json:"testResults"`
}

type Example struct {
	Input  string `json:"input"`
	Answer string `json:"answer"`
}

type ExecutionResult struct {
	Stdout string `json:"stdout"`
	Stderr string `json:"stderr"`
}

type Mutation struct {
}

type Origin struct {
	Authors []string `json:"authors,omitempty"`
	Source  *string  `json:"source,omitempty"`
}

type ProgrammingLanguage struct {
	ID       string  `json:"id"`
	FullName string  `json:"fullName"`
	MonacoID *string `json:"monacoID,omitempty"`
	Enabled  bool    `json:"enabled"`
}

type Query struct {
}

type RuntimeData struct {
	TimeMs   int    `json:"timeMs"`
	MemoryKb int    `json:"memoryKb"`
	ExitCode int    `json:"exitCode"`
	Stdout   string `json:"stdout"`
	Stderr   string `json:"stderr"`
}

type ShallowEvaluation struct {
	ID            string `json:"id"`
	Status        string `json:"status"`
	TotalScore    int    `json:"totalScore"`
	PossibleScore *int   `json:"possibleScore,omitempty"`
}

type StatementInput struct {
	Story  *string `json:"story,omitempty"`
	Input  *string `json:"input,omitempty"`
	Output *string `json:"output,omitempty"`
	Notes  *string `json:"notes,omitempty"`
}

type Submission struct {
	ID             string               `json:"id"`
	TaskFullName   string               `json:"taskFullName"`
	TaskCode       string               `json:"taskCode"`
	AuthorUsername string               `json:"authorUsername"`
	ProgLang       *ProgrammingLanguage `json:"progLang"`
	SubmissionCode string               `json:"submissionCode"`
	EvalResults    *Evaluation          `json:"evalResults"`
	CreatedAt      string               `json:"createdAt"`
}

type Subscription struct {
}

type Task struct {
	TaskID    string       `json:"taskID"`
	Current   *TaskVersion `json:"current"`
	Stable    *TaskVersion `json:"stable,omitempty"`
	CreatedAt string       `json:"createdAt"`
}

type TaskVersion struct {
	VersionID   string       `json:"versionID"`
	Code        string       `json:"code"`
	Name        string       `json:"name"`
	Description *Description `json:"description,omitempty"`
	Constraints *Constraints `json:"constraints"`
	Origin      *Origin      `json:"origin,omitempty"`
	CreatedAt   string       `json:"createdAt"`
}

type Test struct {
	TestID string `json:"testID"`
	Name   string `json:"name"`
	Input  string `json:"input"`
	Answer string `json:"answer"`
}

type TestResult struct {
	ID               string         `json:"id"`
	TestID           string         `json:"testID"`
	UserProgramRData *RuntimeData   `json:"userProgramRData,omitempty"`
	CheckerRData     *RuntimeData   `json:"checkerRData,omitempty"`
	FinalVerdict     TestResultType `json:"finalVerdict"`
}

type User struct {
	ID        string `json:"id"`
	Username  string `json:"username"`
	Email     string `json:"email"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
	IsAdmin   bool   `json:"isAdmin"`
}

type TestResultType string

const (
	TestResultTypeAc  TestResultType = "AC"
	TestResultTypePt  TestResultType = "PT"
	TestResultTypeWa  TestResultType = "WA"
	TestResultTypePe  TestResultType = "PE"
	TestResultTypeTle TestResultType = "TLE"
	TestResultTypeMle TestResultType = "MLE"
	TestResultTypeIle TestResultType = "ILE"
	TestResultTypeIg  TestResultType = "IG"
	TestResultTypeRe  TestResultType = "RE"
	TestResultTypeSv  TestResultType = "SV"
	TestResultTypeIse TestResultType = "ISE"
)

var AllTestResultType = []TestResultType{
	TestResultTypeAc,
	TestResultTypePt,
	TestResultTypeWa,
	TestResultTypePe,
	TestResultTypeTle,
	TestResultTypeMle,
	TestResultTypeIle,
	TestResultTypeIg,
	TestResultTypeRe,
	TestResultTypeSv,
	TestResultTypeIse,
}

func (e TestResultType) IsValid() bool {
	switch e {
	case TestResultTypeAc, TestResultTypePt, TestResultTypeWa, TestResultTypePe, TestResultTypeTle, TestResultTypeMle, TestResultTypeIle, TestResultTypeIg, TestResultTypeRe, TestResultTypeSv, TestResultTypeIse:
		return true
	}
	return false
}

func (e TestResultType) String() string {
	return string(e)
}

func (e *TestResultType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TestResultType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TestResultType", str)
	}
	return nil
}

func (e TestResultType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
