// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"fmt"
	"io"
	"strconv"
)

type Constraints struct {
	TimeLimitMs   int `json:"timeLimitMs"`
	MemoryLimitKb int `json:"memoryLimitKb"`
}

type Description struct {
	Story    string     `json:"story"`
	Input    string     `json:"input"`
	Output   string     `json:"output"`
	Examples []*Example `json:"examples,omitempty"`
	Notes    *string    `json:"notes,omitempty"`
}

type Evaluation struct {
	ID                string             `json:"id"`
	Status            string             `json:"status"`
	TotalScore        int                `json:"totalScore"`
	PossibleScore     *int               `json:"possibleScore,omitempty"`
	RuntimeStatistics *RuntimeStatistics `json:"runtimeStatistics,omitempty"`
	// Some programming languages do not support compilation, so this field may be null.
	CompileRData *RuntimeData  `json:"compileRData,omitempty"`
	TestResults  []*TestResult `json:"testResults"`
}

type Example struct {
	Input  string `json:"input"`
	Answer string `json:"answer"`
}

type ExecutionResult struct {
	Stdout string `json:"stdout"`
	Stderr string `json:"stderr"`
}

type Metadata struct {
	Authors []string `json:"authors,omitempty"`
	Origin  *string  `json:"origin,omitempty"`
}

type Mutation struct {
}

type ProgrammingLanguage struct {
	ID       string  `json:"id"`
	FullName string  `json:"fullName"`
	MonacoID *string `json:"monacoID,omitempty"`
	Enabled  bool    `json:"enabled"`
}

type Query struct {
}

type RuntimeData struct {
	TimeMs   int    `json:"timeMs"`
	MemoryKb int    `json:"memoryKb"`
	ExitCode int    `json:"exitCode"`
	Stdout   string `json:"stdout"`
	Stderr   string `json:"stderr"`
}

type RuntimeStatistics struct {
	AvgTimeMs   int `json:"avgTimeMs"`
	MaxTimeMs   int `json:"maxTimeMs"`
	AvgMemoryKb int `json:"avgMemoryKb"`
	MaxMemoryKb int `json:"maxMemoryKb"`
}

type ShallowEvaluation struct {
	ID            string `json:"id"`
	Status        string `json:"status"`
	TotalScore    int    `json:"totalScore"`
	PossibleScore *int   `json:"possibleScore,omitempty"`
}

type StatementInput struct {
	Story  *string `json:"story,omitempty"`
	Input  *string `json:"input,omitempty"`
	Output *string `json:"output,omitempty"`
	Notes  *string `json:"notes,omitempty"`
}

type Submission struct {
	ID         string               `json:"id"`
	Task       *Task                `json:"task"`
	Language   *ProgrammingLanguage `json:"language"`
	Submission string               `json:"submission"`
	Evaluation *Evaluation          `json:"evaluation"`
	Username   string               `json:"username"`
	CreatedAt  string               `json:"createdAt"`
}

type SubmissionOverview struct {
	ID         string               `json:"id"`
	Task       *TaskOverview        `json:"task"`
	Language   *ProgrammingLanguage `json:"language"`
	Evaluation *ShallowEvaluation   `json:"evaluation"`
	Username   string               `json:"username"`
	CreatedAt  string               `json:"createdAt"`
}

type Task struct {
	TaskID    string       `json:"taskID"`
	Current   *TaskVersion `json:"current"`
	Stable    *TaskVersion `json:"stable,omitempty"`
	CreatedAt string       `json:"createdAt"`
}

type TaskOverview struct {
	TaskID string `json:"taskID"`
	Name   string `json:"name"`
	Code   string `json:"code"`
}

type TaskVersion struct {
	VersionID   string       `json:"versionID"`
	Code        string       `json:"code"`
	Name        string       `json:"name"`
	Description *Description `json:"description,omitempty"`
	Constraints *Constraints `json:"constraints"`
	Metadata    *Metadata    `json:"metadata"`
	CreatedAt   string       `json:"createdAt"`
}

type Test struct {
	TestID string `json:"testID"`
	Name   string `json:"name"`
	Input  string `json:"input"`
	Answer string `json:"answer"`
}

type TestResult struct {
	TimeMs   int            `json:"timeMs"`
	MemoryKb int            `json:"memoryKb"`
	Result   TestResultType `json:"result"`
}

type User struct {
	ID        string `json:"id"`
	Username  string `json:"username"`
	Email     string `json:"email"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
	IsAdmin   bool   `json:"isAdmin"`
}

type TestResultType string

const (
	TestResultTypeAc  TestResultType = "AC"
	TestResultTypePt  TestResultType = "PT"
	TestResultTypeWa  TestResultType = "WA"
	TestResultTypePe  TestResultType = "PE"
	TestResultTypeTle TestResultType = "TLE"
	TestResultTypeMle TestResultType = "MLE"
	TestResultTypeIle TestResultType = "ILE"
	TestResultTypeIg  TestResultType = "IG"
	TestResultTypeRe  TestResultType = "RE"
	TestResultTypeSv  TestResultType = "SV"
	TestResultTypeIse TestResultType = "ISE"
)

var AllTestResultType = []TestResultType{
	TestResultTypeAc,
	TestResultTypePt,
	TestResultTypeWa,
	TestResultTypePe,
	TestResultTypeTle,
	TestResultTypeMle,
	TestResultTypeIle,
	TestResultTypeIg,
	TestResultTypeRe,
	TestResultTypeSv,
	TestResultTypeIse,
}

func (e TestResultType) IsValid() bool {
	switch e {
	case TestResultTypeAc, TestResultTypePt, TestResultTypeWa, TestResultTypePe, TestResultTypeTle, TestResultTypeMle, TestResultTypeIle, TestResultTypeIg, TestResultTypeRe, TestResultTypeSv, TestResultTypeIse:
		return true
	}
	return false
}

func (e TestResultType) String() string {
	return string(e)
}

func (e *TestResultType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TestResultType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TestResultType", str)
	}
	return nil
}

func (e TestResultType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
