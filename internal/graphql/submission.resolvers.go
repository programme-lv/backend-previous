package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"strconv"

	"github.com/programme-lv/backend/internal/services/langs"
	"github.com/programme-lv/backend/internal/services/submissions"
	"github.com/programme-lv/backend/internal/services/tasks"
	"github.com/programme-lv/backend/internal/services/users"
)

// EnqueueSubmissionForPublishedTaskCodeStableTaskVersion is the resolver for the enqueueSubmissionForPublishedTaskCodeStableTaskVersion field.
func (r *mutationResolver) EnqueueSubmissionForPublishedTaskCodeStableTaskVersion(ctx context.Context, taskCode string, languageID string, submissionCode string) (*Submission, error) {
	user, err := r.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	programmingLang, err := langs.FindLanguageByID(r.PostgresDB, languageID)
	if err != nil {
		return nil, err
	}

	taskID, err := tasks.GetTaskIDByPublishedTaskCode(r.PostgresDB, taskCode)
	if err != nil {
		return nil, err
	}

	submissionID, err := submissions.CreateSubmission(r.PostgresDB, submissions.CreateSubmissionParams{
		UserID:            user.ID,
		TaskID:            taskID,
		ProgrammingLangID: programmingLang.ID,
		Submission:        submissionCode,
	})
	if err != nil {
		return nil, err
	}

	stableTaskVersID, err := tasks.GetStableTaskVerssionIDByTaskID(r.PostgresDB, taskID)
	if err != nil {
		return nil, err
	}

	err = submissions.EvaluateSubmission(r.PostgresDB, submissionID, stableTaskVersID,
		r.TestURLs, submissions.TestingDirectorConn{
			GRPCClient: r.DirectorConn.GRPCClient,
			Password:   r.DirectorConn.Password,
		})
	if err != nil {
		return nil, err
	}

	// TODO: return the submission object
	return nil, nil
}

// ListPublicSubmissions is the resolver for the listPublicSubmissions field.
func (r *queryResolver) ListPublicSubmissions(ctx context.Context) ([]*SubmissionOverview, error) {
	// load all non-hidden task submRecords
	submRecords, err := submissions.ListVisibleTaskSubmissionRowsWithEvaluation(r.PostgresDB)
	if err != nil {
		return nil, err
	}

	var gqlSubms []*SubmissionOverview = make([]*SubmissionOverview, 0, len(submRecords))
	for _, subm := range submRecords {
		task, err := tasks.GetTaskObjByTaskID(r.PostgresDB, subm.TaskID, 0, 1)
		if err != nil {
			return nil, err
		}
		user, err := users.GetUserObj(r.PostgresDB, subm.UserID)
		if err != nil {
			return nil, err
		}
		lang, err := langs.GetLangObj(r.PostgresDB, subm.ProgrammingLangID)
		if err != nil {
			return nil, err
		}
		if subm.VisibleEvalID == nil {
			return nil, fmt.Errorf("submission %d has no visible evaluation", subm.ID)
		}
		evalObj, err := submissions.GetEvaluationObj(r.PostgresDB, *subm.VisibleEvalID, false)
		if err != nil {
			return nil, err
		}
		var possibleScore int = 100
		if evalObj.PossibleScore != nil {
			possibleScore = int(*evalObj.PossibleScore)
		}
		marshalledCreatedAt, err := subm.CreatedAt.MarshalText()
		if err != nil {
			return nil, err
		}
		gqlSubm := &SubmissionOverview{
			ID: fmt.Sprint(subm.ID),
			Task: &TaskOverview{
				TaskID: strconv.FormatInt(task.ID, 10),
				Name:   task.Stable.Name,
				Code:   task.Stable.Code,
			},
			Language: &ProgrammingLanguage{
				ID:       fmt.Sprint(lang.ID),
				FullName: lang.Name,
				MonacoID: lang.MonacoID,
				Enabled:  lang.Enabled,
			},
			Evaluation: &ShallowEvaluation{
				ID:            fmt.Sprint(evalObj.ID),
				Status:        evalObj.StatusID,
				TotalScore:    int(evalObj.ReceivedScore),
				PossibleScore: &possibleScore,
			},
			Username:  user.Username,
			CreatedAt: string(marshalledCreatedAt),
		}

		gqlSubms = append(gqlSubms, gqlSubm)
	}

	return gqlSubms, nil
}

// GetSubmission is the resolver for the getSubmission field.
func (r *queryResolver) GetSubmission(ctx context.Context, id string) (*Submission, error) {
	submIDInt64, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, err
	}

	submObj, err := submissions.GetSubmissionObject(r.PostgresDB, submIDInt64)
	if err != nil {
		return nil, err
	}

	gqlSubm, err := internalSubmissionToGQLSubmission(submObj)
	if err != nil {
		return nil, err
	}

	return gqlSubm, nil
}
