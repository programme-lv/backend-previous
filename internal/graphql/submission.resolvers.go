package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/programme-lv/backend/internal/eval/command"
	"github.com/programme-lv/backend/internal/eval/query"
)

// EnqueueSubmissionForPublishedTaskCodeStableTaskVersion is the resolver for the enqueueSubmissionForPublishedTaskCodeStableTaskVersion field.
func (r *mutationResolver) EnqueueSubmissionForPublishedTaskCodeStableTaskVersion(ctx context.Context, taskCode string, languageID string, submissionCode string) (*Submission, error) {
	user, err := r.getUserFromContext(ctx)
	if err != nil {
		return nil, smartError(ctx, err)
	}

	task, err := r.TaskSrv.GetTaskByPublishedCode(taskCode)
	if err != nil {
		return nil, smartError(ctx, err)
	}

	newSubmissionUUID := uuid.New()
	err = r.EvalApp.Commands.SubmitSolution.Handle(ctx, command.SubmitSolution{
		SubmissionUUID: newSubmissionUUID,
		TaskID:         task.ID,
		AuthorID:       user.ID,
		ProgLangID:     languageID,
		Submission:     submissionCode,
	})
	if err != nil {
		return nil, smartError(ctx, err)
	}

	subm, err := r.EvalApp.Queries.GetSubmissionByID.Handle(ctx, query.GetSubmissionByUUID{
		UUID: newSubmissionUUID,
	})
	if err != nil {
		return nil, smartError(ctx, err)
	}

	return mapSubmissionQueryToGQL(subm)
}

// ListPublicSubmissions is the resolver for the listPublicSubmissions field.
func (r *queryResolver) ListPublicSubmissions(ctx context.Context) ([]*Submission, error) {
	submissions, err := r.EvalApp.Queries.AllSubmissions.Handle(ctx, query.AllSubmissions{})
	if err != nil {
		return nil, smartError(ctx, err)
	}

	var gqlSubmissions []*Submission = make([]*Submission, 0, len(submissions))
	for _, submission := range submissions {
		gqlSubm, err := mapSubmissionQueryToGQL(submission)
		if err != nil {
			return nil, err
		}
		gqlSubmissions = append(gqlSubmissions, gqlSubm)
	}

	return gqlSubmissions, nil
}

// GetSubmission is the resolver for the getSubmission field.
func (r *queryResolver) GetSubmission(ctx context.Context, id string) (*Submission, error) {
	subm, err := r.EvalApp.Queries.GetSubmissionByID.Handle(ctx, query.GetSubmissionByUUID{
		UUID: uuid.MustParse(id),
	})
	if err != nil {
		return nil, smartError(ctx, err)
	}

	return mapSubmissionQueryToGQL(subm)
}

// ListSolvedPublishedTaskCodesByUsername is the resolver for the listSolvedPublishedTaskCodesByUsername field.
func (r *queryResolver) ListSolvedPublishedTaskCodesByUsername(ctx context.Context, username string) ([]string, error) {
	panic(fmt.Errorf("not implemented: ListSolvedPublishedTaskCodesByUsername - listSolvedPublishedTaskCodesByUsername"))
}

// OnNewPublicSubmission is the resolver for the onNewPublicSubmission field.
func (r *subscriptionResolver) OnNewPublicSubmission(ctx context.Context) (<-chan *Submission, error) {
	panic(fmt.Errorf("not implemented: OnNewPublicSubmission - onNewPublicSubmission"))
}

// OnSubmissionUpdate is the resolver for the onSubmissionUpdate field.
func (r *subscriptionResolver) OnSubmissionUpdate(ctx context.Context, submissionID string) (<-chan *Submission, error) {
	panic(fmt.Errorf("not implemented: OnSubmissionUpdate - onSubmissionUpdate"))
}
