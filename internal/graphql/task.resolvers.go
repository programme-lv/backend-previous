package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"strconv"

	"github.com/programme-lv/backend/internal/services/tasks"
	"github.com/ztrue/tracerr"
)

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, name string, code string) (*Task, error) {
	user, err := r.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// name must be between 1 and 100 characters
	if len(name) < 1 || len(name) > 100 {
		return nil, fmt.Errorf("name must be between 1 and 100 characters")
	}

	if len(code) < 1 || len(code) > 50 {
		return nil, fmt.Errorf("code must be between 1 and 50 characters")
	}

	// code can only contain lowercase letters and digits
	for _, c := range code {
		if !((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
			return nil, fmt.Errorf("code can only contain lowercase letters and digits")
		}
	}

	taskID, err := tasks.CreateTask(r.PostgresDB, name, code, user.ID)
	if err != nil {
		return nil, err
	}

	taskObj, err := tasks.GetTaskByTaskID(r.PostgresDB, taskID)
	if err != nil {
		return nil, err
	}

	task, err := internalTaskToGQLTask(taskObj)
	if err != nil {
		return nil, err
	}

	return task, nil
}

// UpdateTaskVersionStatement is the resolver for the updateTaskVersionStatement field.
func (r *mutationResolver) UpdateTaskVersionStatement(ctx context.Context, taskVersionID string, statement StatementInput) (*TaskVersion, error) {
	user, err := r.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	taskVersionIDint64, err := strconv.ParseInt(taskVersionID, 10, 64)
	if err != nil {
		return nil, err
	}

	taskID, err := tasks.GetTaskIDByTaskVersionID(r.PostgresDB, taskVersionIDint64)
	if err != nil {
		return nil, err
	}

	canEdit, err := tasks.CanUserEditTask(r.PostgresDB, user.ID, taskID)
	if err != nil {
		return nil, err
	}

	if !canEdit {
		return nil, fmt.Errorf("user does not have permission to edit this task version")
	}

	input := tasks.UpdateTaskVStatementInput{
		Story:  statement.Story,
		Input:  statement.Input,
		Output: statement.Output,
		Notes:  statement.Notes,
	}

	newTaskVersID, err := tasks.UpdateTaskVersionStatement(r.PostgresDB, taskVersionIDint64, input)
	if err != nil {
		tracerr.PrintSourceColor(err)
		return nil, err
	}

	err = tasks.UpdateCurrentTaskVersionID(r.PostgresDB, taskID, newTaskVersID)
	if err != nil {
		return nil, err
	}

	taskVObj, err := tasks.GetTaskVersionByTaskVersionID(r.PostgresDB, newTaskVersID)
	if err != nil {
		return nil, err
	}

	res, err := internalTaskVToGQLTaskV(taskVObj)
	if err != nil {
		return nil, err
	}

	return res, nil
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, taskID string) (bool, error) {
	user, err := r.GetUserFromContext(ctx)
	if err != nil {
		return false, err
	}

	taskIDint64, err := strconv.ParseInt(taskID, 10, 64)
	if err != nil {
		return false, err
	}

	canEdit, err := tasks.CanUserEditTask(r.PostgresDB, user.ID, taskIDint64)
	if err != nil {
		return false, err
	}

	if !canEdit {
		return false, fmt.Errorf("user does not have permission to delete this task")
	}

	err = tasks.DeleteTask(r.PostgresDB, taskIDint64)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ListPublishedTasks is the resolver for the listPublishedTasks field.
func (r *queryResolver) ListPublishedTasks(ctx context.Context) ([]*Task, error) {
	panic(fmt.Errorf("not implemented: ListPublishedTasks - listPublishedTasks"))
}

// GetStableTaskVersionByPublishedTaskCode is the resolver for the getStableTaskVersionByPublishedTaskCode field.
func (r *queryResolver) GetStableTaskVersionByPublishedTaskCode(ctx context.Context, taskCode string) (*TaskVersion, error) {
	panic(fmt.Errorf("not implemented: GetStableTaskVersionByPublishedTaskCode - getStableTaskVersionByPublishedTaskCode"))
}

// GetCurrentTaskVersionByTaskID is the resolver for the getCurrentTaskVersionByTaskID field.
func (r *queryResolver) GetCurrentTaskVersionByTaskID(ctx context.Context, taskID string) (*TaskVersion, error) {
	taskIDint64, err := strconv.ParseInt(taskID, 10, 64)
	if err != nil {
		return nil, err
	}

	taskVObj, err := tasks.GetCurrentTaskVersionByTaskID(r.PostgresDB, taskIDint64)
	if err != nil {
		return nil, err
	}

	res, err := internalTaskVToGQLTaskV(taskVObj)
	if err != nil {
		return nil, err
	}

	return res, nil
}

// ListEditableTasks is the resolver for the listEditableTasks field.
func (r *queryResolver) ListEditableTasks(ctx context.Context) ([]*Task, error) {
	user, err := r.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	taskIds, err := tasks.ListEditableTaskIDs(r.PostgresDB, user.ID)
	if err != nil {
		return nil, err
	}

	var res []*Task = make([]*Task, 0)
	for _, taskID := range taskIds {
		taskObj, err := tasks.GetTaskByTaskID(r.PostgresDB, taskID)
		if err != nil {
			tracerr.PrintSourceColor(err)
			return nil, err
		}

		if taskObj.Current == nil {
			continue
		}

		task, err := internalTaskToGQLTask(taskObj)
		if err != nil {
			return nil, err
		}

		res = append(res, task)
	}

	return res, nil
}
