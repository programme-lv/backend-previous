package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"fmt"

	"github.com/programme-lv/backend/internal/database"
	"golang.org/x/exp/slog"
)

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, name string, code string) (*Task, error) {
	if len(name) == 0 || len(code) == 0 {
		return nil, fmt.Errorf("name and code must not be empty")
	}

	nameMaxLength := 50
	codeMaxLength := 20

	if len(name) > nameMaxLength {
		return nil, fmt.Errorf("name must be at most %d characters long", nameMaxLength)
	}

	if len(code) > codeMaxLength {
		return nil, fmt.Errorf("code must be at most %d characters long", codeMaxLength)
	}

	requestLogger := r.Logger.With(slog.String("request_type", "create_task"),
		slog.String("name", name), slog.String("code", code))

	requestLogger.Info("received create task request")

	user, err := r.GetUserFromContext(ctx)
	if err != nil {
		requestLogger.Error("failed to get user from context", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger = requestLogger.With(slog.Int64("user_id", user.ID))
	requestLogger.Info("got user from context")

	// TODO: check if task with the same name or code already exists

	t, err := r.DB.Beginx()
	if err != nil {
		requestLogger.Error("failed to begin transaction", slog.String("error", err.Error()))
		return nil, err
	}

	stmt := "INSERT INTO tasks (created_by, relevant_version) VALUES ($1, $2) RETURNING id"
	var taskId int64
	err = t.QueryRow(stmt, user.ID, nil).Scan(&taskId)
	if err != nil {
		t.Rollback()
		requestLogger.Error("failed to insert task", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger = requestLogger.With(slog.Int64("task_id", taskId))

	var task database.Task
	err = t.Get(&task, "SELECT * FROM tasks WHERE id = $1", taskId)
	if err != nil {
		t.Rollback()
		requestLogger.Error("failed to get task", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger.Info("created task successfully")

	DefaultTimeLimitMs := 1000
	DefaultMemoryLimitKb := 256000

	stmt = "INSERT INTO task_versions (task_id, short_code, full_name, time_lim_ms, mem_lim_kb, testing_type_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id"
	var versionId int64
	err = t.QueryRow(stmt, task.ID, code, name, DefaultTimeLimitMs, DefaultMemoryLimitKb, "simple").Scan(&versionId)
	if err != nil {
		t.Rollback()
		requestLogger.Error("failed to insert task version", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger = requestLogger.With(slog.Int64("version_id", versionId))

	var version database.TaskVersion
	err = t.Get(&version, "SELECT * FROM task_versions WHERE id = $1", versionId)
	if err != nil {
		t.Rollback()
		requestLogger.Error("failed to get task version", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger.Info("inserted task version successfully")

	// TODO: update task relevant version

	err = t.Commit()
	if err != nil {
		requestLogger.Error("failed to commit transaction", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger.Info("committed transaction successfully")

	// TODO: create description, constraints and metadata

	description := Description{
		ID:       "0",
		Story:    "",
		Input:    "",
		Output:   "",
		Examples: nil,
		Notes:    "",
	}

	constraints := Constraints{
		TimeLimitMs:   version.TimeLimMs,
		MemoryLimitKb: version.MemLimKb,
	}

	metadata := Metadata{
		Authors: []string{},
		Origin:  nil,
	}

	updatedAt := version.UpdatedAt
	if updatedAt == nil {
		updatedAt = &task.CreatedAt
	}

	return &Task{
		ID:          fmt.Sprintf("%d", task.ID),
		Code:        version.ShortCode,
		Name:        version.FullName,
		Description: &description,
		Constraints: &constraints,
		Metadata:    &metadata,
		CreatedAt:   task.CreatedAt.UTC().String(),
		UpdatedAt:   updatedAt.UTC().String(),
	}, nil
}

// UpdateTaskMetadata is the resolver for the updateTaskMetadata field.
func (r *mutationResolver) UpdateTaskMetadata(ctx context.Context, id string, authors []string, origin *string) (*Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTaskMetadata - updateTaskMetadata"))
}

// UpdateTaskDescription is the resolver for the updateTaskDescription field.
func (r *mutationResolver) UpdateTaskDescription(ctx context.Context, id string, code *string, name *string, story *string, input *string, output *string, notes *string) (*Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTaskDescription - updateTaskDescription"))
}

// UpdateTaskExamples is the resolver for the updateTaskExamples field.
func (r *mutationResolver) UpdateTaskExamples(ctx context.Context, id string, inputs []string, outputs []string) (*Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTaskExamples - updateTaskExamples"))
}

// UpdateTaskConstraints is the resolver for the updateTaskConstraints field.
func (r *mutationResolver) UpdateTaskConstraints(ctx context.Context, id string, timeLimitMs *int, memoryLimitKb *int) (*Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTaskConstraints - updateTaskConstraints"))
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (*Task, error) {
	panic(fmt.Errorf("not implemented: DeleteTask - deleteTask"))
}

// ListTasks is the resolver for the listTasks field.
func (r *queryResolver) ListTasks(ctx context.Context) ([]*Task, error) {
	panic(fmt.Errorf("not implemented: ListTasks - listTasks"))
}

// GetTask is the resolver for the getTask field.
func (r *queryResolver) GetTask(ctx context.Context, id string) (*Task, error) {
	panic(fmt.Errorf("not implemented: GetTask - getTask"))
}

// ListTaskOrigins is the resolver for the listTaskOrigins field.
func (r *queryResolver) ListTaskOrigins(ctx context.Context) ([]string, error) {
	panic(fmt.Errorf("not implemented: ListTaskOrigins - listTaskOrigins"))
}
