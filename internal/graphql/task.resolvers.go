package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"log"

	"github.com/programme-lv/backend/internal/database"
	"golang.org/x/exp/slog"
)

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, name string, code string) (*Task, error) {
	if len(name) == 0 || len(code) == 0 {
		return nil, fmt.Errorf("name and code must not be empty")
	}

	nameMaxLength := 50
	codeMaxLength := 20

	if len(name) > nameMaxLength {
		return nil, fmt.Errorf("name must be at most %d characters long", nameMaxLength)
	}

	if len(code) > codeMaxLength {
		return nil, fmt.Errorf("code must be at most %d characters long", codeMaxLength)
	}

	// code can contain only lowercase latin letters and digits
	for _, c := range code {
		if !((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
			return nil, fmt.Errorf("task code can contain only lowercase latin letters and digits")
		}
	}

	requestLogger := r.Logger.With(slog.String("request_type", "create_task"),
		slog.String("name", name), slog.String("code", code))

	requestLogger.Info("received create task request")

	user, err := r.GetUserFromContext(ctx)
	if err != nil {
		requestLogger.Error("failed to get user from context", slog.String("error", err.Error()))
		return nil, err
	}

	if !user.IsAdmin {
		requestLogger.Error("only admins can create tasks")
		return nil, fmt.Errorf("only admins can create tasks")
	}

	requestLogger = requestLogger.With(slog.Int64("user_id", user.ID))
	requestLogger.Info("got user from context")

	publishedVersionIdsStmt := "SELECT DISTINCT published_version_id FROM tasks WHERE published_version_id IS NOT NULL"
	stmt := "SELECT COUNT(*) from task_versions WHERE (short_code = $1 OR full_name = $2) AND task_versions.id IN (%s);"
	stmt = fmt.Sprintf(stmt, publishedVersionIdsStmt)
	var count int
	err = r.DB.Get(&count, stmt, code, name)
	if err != nil {
		requestLogger.Error("failed to check if task with the same name or code already exists", slog.String("error", err.Error()))
		return nil, err
	}

	if count > 0 {
		return nil, fmt.Errorf("task with the same name or code is already published")
	}

	t, err := r.DB.Beginx()
	if err != nil {
		requestLogger.Error("failed to begin transaction", slog.String("error", err.Error()))
		return nil, err
	}

	stmt = "INSERT INTO tasks (created_by_id, relevant_version_id) VALUES ($1, $2) RETURNING id"
	var taskId int64
	err = t.QueryRow(stmt, user.ID, nil).Scan(&taskId)
	if err != nil {
		t.Rollback()
		requestLogger.Error("failed to insert task", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger = requestLogger.With(slog.Int64("task_id", taskId))

	var task database.Task
	err = t.Get(&task, "SELECT * FROM tasks WHERE id = $1", taskId)
	if err != nil {
		t.Rollback()
		requestLogger.Error("failed to get task", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger.Info("created task successfully")

	DefaultTimeLimitMs := 1000
	DefaultMemoryLimitKb := 256000

	stmt = `INSERT INTO task_versions
    (task_id, short_code, full_name, time_lim_ms, mem_lim_kb, testing_type_id)
    VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`

	var versionId int64
	err = t.QueryRow(stmt, task.ID, code, name, DefaultTimeLimitMs, DefaultMemoryLimitKb, "simple").Scan(&versionId)
	if err != nil {
		t.Rollback()
		requestLogger.Error("failed to insert task version", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger = requestLogger.With(slog.Int64("version_id", versionId))

	var version database.TaskVersion
	err = t.Get(&version, "SELECT * FROM task_versions WHERE id = $1", versionId)
	if err != nil {
		t.Rollback()
		requestLogger.Error("failed to get task version", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger.Info("inserted task version successfully")

	_, err = t.Exec("UPDATE tasks SET relevant_version_id = $1 WHERE id = $2", versionId, task.ID)
	if err != nil {
		t.Rollback()
		requestLogger.Error("failed to update task relevant version", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger.Info("updated task relevant version successfully")

	stmt = `INSERT INTO public.markdown_statements(
	story, input, output, notes, scoring, task_version_id)
	VALUES ($1, $2, $3, $4, $5, $6)`

	_, err = t.Exec(stmt, "", "", "", "", "", versionId)
	if err != nil {
		t.Rollback()
		requestLogger.Error("failed to insert markdown statement", slog.String("error", err.Error()))
		return nil, err
	}

	err = t.Commit()
	if err != nil {
		requestLogger.Error("failed to commit transaction", slog.String("error", err.Error()))
		return nil, err
	}

	requestLogger.Info("committed transaction successfully")

	description := Description{
		ID:       "0",
		Story:    "",
		Input:    "",
		Output:   "",
		Examples: nil,
		Notes:    nil,
	}

	constraints := Constraints{
		TimeLimitMs:   version.TimeLimMs,
		MemoryLimitKb: version.MemLimKb,
	}

	metadata := Metadata{
		Authors: []string{},
		Origin:  nil,
	}

	updatedAt := version.UpdatedAt
	if updatedAt == nil {
		updatedAt = &task.CreatedAt
	}

	// TODO: add default author

	return &Task{
		ID:          fmt.Sprintf("%d", task.ID),
		Code:        version.ShortCode,
		Name:        version.FullName,
		Description: &description,
		Constraints: &constraints,
		Metadata:    &metadata,
		CreatedAt:   task.CreatedAt.UTC().String(),
		UpdatedAt:   updatedAt.UTC().String(),
	}, nil
}

// UpdateTaskMetadata is the resolver for the updateTaskMetadata field.
func (r *mutationResolver) UpdateTaskMetadata(ctx context.Context, id string, authors []string, origin *string) (*Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTaskMetadata - updateTaskMetadata"))
}

// UpdateTaskDescription is the resolver for the updateTaskDescription field.
func (r *mutationResolver) UpdateTaskDescription(ctx context.Context, id string, code *string, name *string, story *string, input *string, output *string, notes *string) (*Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTaskDescription - updateTaskDescription"))
}

// UpdateTaskExamples is the resolver for the updateTaskExamples field.
func (r *mutationResolver) UpdateTaskExamples(ctx context.Context, id string, inputs []string, outputs []string) (*Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTaskExamples - updateTaskExamples"))
}

// UpdateTaskConstraints is the resolver for the updateTaskConstraints field.
func (r *mutationResolver) UpdateTaskConstraints(ctx context.Context, id string, timeLimitMs *int, memoryLimitKb *int) (*Task, error) {
	panic(fmt.Errorf("not implemented: UpdateTaskConstraints - updateTaskConstraints"))
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (*Task, error) {
	panic(fmt.Errorf("not implemented: DeleteTask - deleteTask"))
}

// ListTasks is the resolver for the listTasks field.
func (r *queryResolver) ListTasks(ctx context.Context) ([]*Task, error) {
	requestLogger := r.Logger.With(slog.String("resolver", "listTasks"))
	requestLogger.Info("received list tasks request")

	var tasks []database.Task
	err := r.DB.Select(&tasks, "SELECT * FROM tasks")
	if err != nil {
		requestLogger.Error("failed to select tasks", slog.String("error", err.Error()))
		return nil, err
	}

	var versions []database.TaskVersion
	err = r.DB.Select(&versions, "SELECT * FROM task_versions")
	if err != nil {
		requestLogger.Error("failed to select task versions", slog.String("error", err.Error()))
		return nil, err
	}

	versionIdsToVersions := make(map[int64]database.TaskVersion)
	for _, version := range versions {
		versionIdsToVersions[version.ID] = version
	}

	var mdStatements []database.MarkdownStatement
	err = r.DB.Select(&mdStatements, "SELECT * FROM markdown_statements")
	if err != nil {
		requestLogger.Error("failed to select markdown statements", slog.String("error", err.Error()))
		return nil, err
	}

	taskIdsToMdStatements := make(map[int64]*database.MarkdownStatement)
	for _, mdStatement := range mdStatements {
		taskIdsToMdStatements[mdStatement.TaskVersionID] = &mdStatement
	}

	var result []*Task
	for _, task := range tasks {
		if task.RelevantVersionID == nil {
			requestLogger.Error("task has no relevant version", slog.Int64("task_id", task.ID))
			continue
		}
		version, ok := versionIdsToVersions[*task.RelevantVersionID]
		if !ok {
			requestLogger.Error("failed to find relevant version for task", slog.Int64("task_id", task.ID))
			continue
		}

		log.Println("relevant version id:", *task.RelevantVersionID)
		log.Println("version id:", version.ID)

		statement, ok := taskIdsToMdStatements[version.ID]
		if !ok {
			requestLogger.Error("failed to find markdown statement for task", slog.Int64("task_id", task.ID))
			continue
		}

		result = append(result, &Task{
			ID:   fmt.Sprintf("%d", version.TaskID),
			Code: version.ShortCode,
			Name: version.FullName,
			Description: &Description{
				ID:       fmt.Sprintf("%d", statement.ID),
				Story:    statement.Story,
				Input:    statement.Input,
				Output:   statement.Output,
				Examples: nil, // TODO: fetch examples
				Notes:    statement.Notes,
			},
			Constraints: &Constraints{
				TimeLimitMs:   version.TimeLimMs,
				MemoryLimitKb: version.MemLimKb,
			},
			Metadata: &Metadata{
				Authors: []string{}, // TODO: fetch authors
				Origin:  version.Origin,
			},
			CreatedAt: task.CreatedAt.UTC().String(),
			UpdatedAt: version.CreatedAt.UTC().String(),
		})
	}

	requestLogger.Info("successfully retrieved tasks")
	return result, nil
}

// GetRelevantTaskByID is the resolver for the getRelevantTaskById field.
func (r *queryResolver) GetRelevantTaskByID(ctx context.Context, id string) (*Task, error) {
	requestLogger := r.Logger.With(slog.String("resolver", "GetRelevantTaskByID"))
	requestLogger.Info("received get relevant task by id request")

	// fetch task from database
	stmt := `SELECT * FROM tasks WHERE id = $1`
	var task database.Task
	err := r.DB.Get(&task, stmt, id)
	if err != nil {
		requestLogger.Error("failed to select task", slog.String("error", err.Error()))
		return nil, err
	}

	// TODO: later on we will have to distinguish requests between public version
	if task.RelevantVersionID == nil {
		requestLogger.Error("task has no relevant version", slog.Int64("task_id", task.ID))
		return nil, err
	}

	// fetch task version from database
	stmt = `SELECT * FROM task_versions WHERE id = $1`
	var version database.TaskVersion
	err = r.DB.Get(&version, stmt, *task.RelevantVersionID)
	if err != nil {
		requestLogger.Error("failed to select task version", slog.String("error", err.Error()))
		return nil, err
	}

	// fetch markdown statement from database
	stmt = `SELECT * FROM markdown_statements WHERE task_version_id = $1`
	var mdStatement database.MarkdownStatement
	err = r.DB.Get(&mdStatement, stmt, version.ID)
	if err != nil {
		requestLogger.Error("failed to select markdown statement", slog.String("error", err.Error()))
		return nil, err
	}

	return &Task{
		ID:   fmt.Sprintf("%d", version.TaskID),
		Code: version.ShortCode,
		Name: version.FullName,
		Description: &Description{
			ID:       fmt.Sprintf("%d", mdStatement.ID),
			Story:    mdStatement.Story,
			Input:    mdStatement.Input,
			Output:   mdStatement.Output,
			Examples: nil, // TODO: fetch examples
			Notes:    mdStatement.Notes,
		},
		Constraints: &Constraints{
			TimeLimitMs:   version.TimeLimMs,
			MemoryLimitKb: version.MemLimKb,
		},
		Metadata: &Metadata{
			Authors: []string{}, // TODO: fetch authors
			Origin:  version.Origin,
		},
		CreatedAt: task.CreatedAt.UTC().String(),
		UpdatedAt: version.CreatedAt.UTC().String(),
	}, nil
}

// GetPublicTaskByCode is the resolver for the getPublicTaskByCode field.
func (r *queryResolver) GetPublicTaskByCode(ctx context.Context, code string) (*Task, error) {
	panic(fmt.Errorf("not implemented: GetPublicTaskByCode - getPublicTaskByCode"))
}

// ListTaskOrigins is the resolver for the listTaskOrigins field.
func (r *queryResolver) ListTaskOrigins(ctx context.Context) ([]string, error) {
	panic(fmt.Errorf("not implemented: ListTaskOrigins - listTaskOrigins"))
}
